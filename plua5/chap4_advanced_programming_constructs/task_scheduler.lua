--[[
Sample Program: 

To illustrate advanced function techniques and closures in a more comprehensive scenario, consider
a simple task scheduler. The scheduler will allow you to register tasks, each encapsulated within a
closure that mantains its own state, and then execute them sequentially. This example highlights the
use of closures for state encapsulation and higher-order functions for managing tasks
]]

-- define a task scheduler that stores tasks ina tble
local TaskScheduler = {}

-- create a new scheduler instance
function TaskScheduler:new()
  local scheduler = {tasks={}}
  setmetatable(scheduler,self)
  self.__index = self
  return scheduler
end

-- method to add a task to the scheduler; each task is a function
function TaskScheduler:addTask(taskFunc)
  table.insert(self.tasks,taskFunc)
end

-- run all tasks sequentially
function TaskScheduler:runTasks()
  for index,task in ipairs(self.tasks) do
    print('Running Task ' .. index .. ':')
    task() -- execute the task, which may be a closure with its own state
  end
end

-- create a scheduler instance
local scheduler = TaskScheduler:new()

-- add a task that counts from 1 to 3
scheduler:addTask(function()
  local count = 0
  for i = 1,3 do
    count = count + 1
    print('Task 1 count:',count)
  end
end)

-- add a task that greets multiple names using a closure
scheduler:addTask(function()
  local greeter = createGreeter('Greetings')
  local names = {'Alica','Bob','Charlie'}
  for _,name in ipairs(names) do
    print(greeter(name))
  end
end)

function createGreeter(greeting)
  return function(name)
    return greeting .. ', ' .. name .. '!'
  end
end

scheduler:runTasks()

--[[

In this example I'll type out all the summary so I make sure to understand it. The TaskScheduler object
is defined using a table and metatable appraoch to simulate OOP. The schedulerr maintains a list of tasks
each added via an addTask method. This tasks themselves are closures that encapsulate their own state. 
One task counts from 1 to 3 and the other usees a custom greeter function generated by createGreeter
By calling runTasks, the scheduler iterates through the task list and executes each task in sequence, 
demonstrating how closures and higher-order functions can be integrated into a modular and reusable
code block.

Regarding the setmetatable approach...
-- NOTE this is the key then. Here we are creating an index back to 'self' and then our instance is 
-- setmetatabled directly to self (TaskScheduler) which points back to itself for any functions not in the instance.

-- This is a smoother and cleaner way to do this. The step of creating a separate metatable and 
-- pointing our instance to it with setmetatable shows us what's happening
-- but its not needed. We can just use ' __index'  and point our 'class' to itself
-- we get the same result, but its much cleaner now that I know what's going on
-- underneath

-- we can also build onto this with inheritance rather than copying all the functions to each table
-- so we need to make our base 'class' abstract or REMOVE THE ABILITY TO MAKE INSTANCES FROM IT. If we want
-- it to serve as a base class for many different sub-classes of schedulers
]]

